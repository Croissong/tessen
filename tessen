#!/bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later

# shell "strict" mode
set -uo pipefail
readonly PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
export PATH
umask 077

# initialize the global variables
BACKEND="bemenu"
CLIP_TIME=15
WTYPE=""
readonly PASS_STORE="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
PASSFILE=""
declare -A PASSDATA_ARR
USERNAME=""
PASSWORD=""
CHOICE=""

# display and get the shortened path of the password file
get_pass_file() {
  local tmp_pass_1 tmp_pass_2 tmp_pass_3

  # temporarily enable globbing to get the list of gpg files
  shopt -s nullglob globstar
  tmp_pass_1=("$PASS_STORE"/**/*.gpg)
  tmp_pass_2=("${tmp_pass_1[@]#"$PASS_STORE"/}")
  tmp_pass_3=("${tmp_pass_2[@]%.gpg}")
  shopt -u nullglob globstar

  PASSFILE="$(printf '%s\n' "${tmp_pass_3[@]}" | "${BACKEND[@]}")"

  if ! [[ -e "$PASS_STORE/$PASSFILE".gpg ]]; then
    exit 1
  fi
}

# get the password data including username and other keys
get_pass_data() {
  local passdata passdata_regex idx key val

  mapfile -t passdata < <(pass "$PASSFILE")
  # ASSUMPTION: the key can contain alphanumerics, spaces, hyphen, underscore
  #             the value can contain anything but it has to follow after a space
  passdata_regex="^[[:alnum:][:blank:]_-]+:[[:blank:]].+$"
  # ASSUMPTION: the basename of the gpg file is the username although one can still
  #             select a username field inside the file
  USERNAME="${PASSFILE##*/}"
  # ASSUMPTION: the first line of $PASSFILE will contain the password
  PASSWORD="${passdata[0]}"

  # skip the password, validate each entry against $passdata_regex, store valid results
  # ASSUMPTION: each key is unique otherwise, the value of the last non-unique key will be used
  for idx in "${passdata[@]:1}"; do
    if [[ "$idx" =~ $passdata_regex ]]; then
      key="${idx%%:*}"
      val="${idx#*: }"
      PASSDATA_ARR["$key"]="$val"
    else
      continue
    fi
  done
}

# get the key that the user chooses to copy or autotype
choice_data() {
  local ch flag choice_arr
  flag=""
  choice_arr=("autotype" "username" "password" "${!PASSDATA_ARR[@]}")

  if [[ "$WTYPE" -eq 1 ]]; then
    CHOICE="$(printf '%s\n' "${choice_arr[@]}" | "${BACKEND[@]}")"
  else
    CHOICE="$(printf '%s\n' "${choice_arr[@]:1}" | "${BACKEND[@]}")"
  fi

  for ch in "${choice_arr[@]}"; do
    if [[ "$CHOICE" == "$ch" ]]; then
      flag=1
    fi
  done

  if [[ "$flag" -ne 1 ]]; then
    exit 1
  fi
}

# the menu for selecting and copying the decrypted data
key_menu_copy() {
  if [[ "$CHOICE" == "username" ]]; then
    wl-copy "$USERNAME"
    notify-send "username copied, clearing in $CLIP_TIME seconds ..."
    clean
  elif [[ "$CHOICE" == "password" ]]; then
    wl-copy "$PASSWORD"
    notify-send "password copied, clearing in $CLIP_TIME seconds ..."
    clean
  elif [[ -n "${PASSDATA_ARR[$CHOICE]}" ]]; then
    wl-copy "${PASSDATA_ARR[$CHOICE]}"
    notify-send "$CHOICE copied, clearing in $CLIP_TIME seconds ..."
    clean
  else
    exit 1
  fi
}

# the menu for selecting and autotyping the decrypted data
key_menu_autotype() {
  if [[ "$CHOICE" == "autotype" ]]; then
    wtype -s 100 "$USERNAME" && wtype -s 100 -k Tab -- && wtype -s 100 "$PASSWORD"
    exit 0
  elif [[ "$CHOICE" == "username" ]]; then
    wtype "$USERNAME"
    exit 0
  elif [[ "$CHOICE" == "password" ]]; then
    wtype "$PASSWORD"
    exit 0
  elif [[ -n "${PASSDATA_ARR[$CHOICE]}" ]]; then
    wtype "${PASSDATA_ARR[$CHOICE]}"
    exit 0
  else
    exit 1
  fi
}

print_help() {
  printf '%s\n' "tessen: copy or autotype your PASSWORD_STORE_DIR data" ""
  printf '%s\n' "tessen can use one of the following backends"
  printf '%s\n' "       - bemenu"
  printf '%s\n' "       - rofi" ""
  printf '%s\n' "usage: [-ha] [-b backend] [-s seconds]"
  printf '%s\n' "Command Summary:"
  printf '%s\n' "       -h              show this help menu"
  printf '%s\n' "       -a              autotype data instead of copying"
  printf '%s\n' "       -b bemenu/rofi  choose either bemenu or rofi"
  printf '%s\n' "       -s seconds      number of seconds to keep copied data in clipboard" ""
  printf '%s\n' "When using [-a], [-s seconds] will have no effect"
  printf '%s\n' "tessen will use bemenu and will copy data by default if no options are provided" ""
  printf '%s\n' "Examples:"
  printf '%s\n' "       autotype data in PASSWORD_STORE_DIR using bemenu"
  printf '%s\n' '       ayushnix@laptop ~ $ tessen -a -b bemenu' ''
  printf '%s\n' "       copy data from PASSWORD_STORE_DIR using rofi to the clipboard for 30 seconds"
  printf '%s\n' '       ayushnix@laptop ~ $ tessen -b rofi -s 30' ''
  printf '%s\n' "If you're using the sway window manager, you can add tessen to your sway config file"
  # shellcheck disable=SC2016
  printf '%s\n' '       bindsym $mod+z exec tessen' ''
  printf '%s\n' "For more details, visit https://github.com/ayushnix/tessen"
}

validate_backend() {
  if [[ "$BACKEND" == "bemenu" ]]; then
    bmn_opt=("-i -l 10 -w --scrollbar=autohide -n")
    readonly BEMENU_OPTS="${BEMENU_OPTS:-${bmn_opt[*]}}"
    export BEMENU_OPTS
    unset -v bmn_opt
  elif [[ "$BACKEND" == "rofi" ]]; then
    BACKEND=(rofi -dmenu)
  else
    exit 1
  fi
}

validate_clip_time() {
  local clip_regex

  clip_regex="^[[:digit:]]+$"

  if [[ "$CLIP_TIME" =~ $clip_regex ]]; then
    return 0
  else
    notify-send "invalid clipboard time provided"
    exit 1
  fi
}

clean() {
  {
    sleep "$CLIP_TIME"
    wl-copy --clear
  } > /dev/null 2>&1 &
  disown
  unset -v PASSFILE USERNAME PASSWORD PASSDATA_ARR CHOICE
}

die() {
  wl-copy --clear
  unset -v PASSFILE USERNAME PASSWORD PASSDATA_ARR CHOICE
}

main() {
  # exit if the password store directory doesn't exist
  if ! [[ -d "$PASS_STORE" ]]; then
    notify-send "password store not found"
    exit 1
  fi

  # parse any options given by the user
  # shellcheck disable=SC2178
  # we initialized BACKEND as a variable but then used it as an array in case rofi was chosen
  # but this is done after this getopts loop, not before
  while getopts ':hab:s:' opt; do
    case "$opt" in
      h)
        print_help
        exit 0
        ;;
      a) WTYPE=1 ;;
      b) BACKEND="$OPTARG" ;;
      s) CLIP_TIME="$OPTARG" ;;
      \?)
        notify-send "invalid option: -$OPTARG"
        exit 1
        ;;
      :)
        notify-send "option -$OPTARG requires a value"
        exit 1
        ;;
    esac
  done
  unset -v opt
  shift $((OPTIND - 1))

  validate_backend
  validate_clip_time

  readonly WTYPE
  readonly BACKEND
  readonly CLIP_TIME

  trap 'die' EXIT TERM
  get_pass_file
  get_pass_data
  choice_data

  if [[ "$WTYPE" -eq 1 ]]; then
    key_menu_autotype
  else
    key_menu_copy
  fi
  trap - EXIT TERM
}

main "$@"
