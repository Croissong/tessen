#!/bin/bash
# SPDX-License-Identifier: MIT

# shell "strict" mode
set -uo pipefail
readonly PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
export PATH
umask 077

print_help() {
  printf '%s\n' "tessen - select, autotype, and copy your password-store data"
  printf '%s\n' "tessen can use one of the following backends to process password-store data"
  printf '%s\n' "    - bemenu (copy + autotype) - the default choice"
  printf '%s\n' "    - rofi (copy + autotype) - lbonn wayland fork"
  printf '%s\n' "    - fzf (copy only when run from a terminal) - limited functionality" ""
  printf '%s\n' "usage: [-ha] [-b backend] [-s seconds]"
  printf '%s\n' "Command Summary:"
  printf '%s\n' "    -h         show this help menu"
  printf '%s\n' "    -a         autotype data instead of copying"
  printf '%s\n' "    -b         choose either bemenu, rofi, or fzf"
  printf '%s\n' "    -s         number of seconds to keep copied data in clipboard"
}

BACKEND="bemenu"
CLIP_TIME=15
WTYPE=""

while getopts ':hab:s:' opt; do
  case "$opt" in
    h)
      print_help
      exit 0
      ;;
    a) WTYPE=1 ;;
    b) BACKEND="$OPTARG" ;;
    s) CLIP_TIME="$OPTARG" ;;
    \?)
      notify-send "invalid option: -$OPTARG"
      exit 1
      ;;
    :)
      notify-send "option -$OPTARG requires a value"
      exit 1
      ;;
  esac
done
unset -v opt
shift $((OPTIND - 1))

readonly CLIP_TIME
readonly BACKEND
readonly WTYPE

# validate $BACKEND and set the default options for bemenu and fzf
if [[ "$BACKEND" == "bemenu" ]]; then
  bmn_opt=("-i -l 10 -w --scrollbar=autohide -n")
  readonly BEMENU_OPTS="${BEMENU_OPTS:-${bmn_opt[*]}}"
  export BEMENU_OPTS
  unset -v bmn_opt
elif [[ "$BACKEND" == "rofi" ]]; then
  true
elif [[ "$BACKEND" == "fzf" ]]; then
  readonly FZF_DEFAULT_COMMAND=""
  fzf_opt=("--no-multi --height=100 --info=hidden --prompt='pass: ' --layout=reverse")
  readonly FZF_DEFAULT_OPTS="${fzf_opt[*]}"
  export FZF_DEFAULT_COMMAND
  export FZF_DEFAULT_OPTS
  unset -v fzf_opt
else
  exit 1
fi

# validate the value of CLIP_TIME
check_clip_time() {
  local clip_regex

  clip_regex="^[[:digit:]]+$"

  if [[ "$CLIP_TIME" =~ $clip_regex ]]; then
    return 0
  else
    notify-send "invalid clipboard time provided"
    exit 1
  fi
}
check_clip_time

# initialize the primary global variables
readonly PASS_STORE="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
PASSFILE=""             # password file chosen by the user for decryption
declare -A PASSDATA_ARR # decrypted password-store data except the password
USERNAME=""
PASSWORD=""
CHOICE=""

# exit if the password store directory doesn't exist
if ! [[ -d "$PASS_STORE" ]]; then
  notify-send "password store not found"
  exit 1
fi

# display and get the shortened path of the password file
get_pass_file() {
  local tmp_pass_1 tmp_pass_2 tmp_pass_3

  # temporarily enable globbing to get the list of gpg files
  shopt -s nullglob globstar
  tmp_pass_1=("$PASS_STORE"/**/*.gpg)
  tmp_pass_2=("${tmp_pass_1[@]#"$PASS_STORE"/}")
  tmp_pass_3=("${tmp_pass_2[@]%.gpg}")
  shopt -u nullglob globstar

  if [[ "$BACKEND" == "bemenu" ]]; then
    PASSFILE="$(printf '%s\n' "${tmp_pass_3[@]}" | bemenu)"
  elif [[ "$BACKEND" == "rofi" ]]; then
    PASSFILE="$(printf '%s\n' "${tmp_pass_3[@]}" | rofi -dmenu)"
  elif [[ "$BACKEND" == "fzf" ]]; then
    PASSFILE="$(printf '%s\n' "${tmp_pass_3[@]}" | fzf --preview='pass {}')"
  else
    exit 1
  fi

  if [[ -z "$PASSFILE" ]]; then
    exit 1
  fi
}

# get the password data including username and other keys
get_pass_data() {
  local passdata passdata_regex idx key val

  mapfile -t passdata < <(pass "$PASSFILE")
  # ASSUMPTION: the key can contain alphanumerics, spaces, hyphen, underscore
  #             the value can contain anything but it has to follow after a space
  passdata_regex="^[[:alnum:][:blank:]_-]+:[[:blank:]].+$"
  # ASSUMPTION: the basename of the gpg file is the username although one can still
  #             select a username field inside the file
  USERNAME="${PASSFILE##*/}"
  # ASSUMPTION: the first line of $PASSFILE will contain the password
  PASSWORD="${passdata[0]}"

  # skip the password, validate each entry against $passdata_regex, store valid results
  # ASSUMPTION: each key is unique otherwise, the value of the last non-unique key will be used
  for idx in "${passdata[@]:1}"; do
    if [[ "$idx" =~ $passdata_regex ]]; then
      key="${idx%%:*}"
      val="${idx##*: }"
      PASSDATA_ARR["$key"]="$val"
    else
      continue
    fi
  done
}

# get the key that the user chooses to copy
copy_choice_data() {
  if [[ "$BACKEND" == "bemenu" ]]; then
    CHOICE="$(printf '%s\n' "username" "password" "${!PASSDATA_ARR[@]}" | bemenu)"
  elif [[ "$BACKEND" == "rofi" ]]; then
    CHOICE="$(printf '%s\n' "username" "password" "${!PASSDATA_ARR[@]}" | rofi -dmenu)"
  elif [[ "$BACKEND" == "fzf" ]]; then
    CHOICE="$(printf '%s\n' "username" "password" "${!PASSDATA_ARR[@]}" | fzf)"
  else
    exit 1
  fi

  if [[ -z "$CHOICE" ]]; then
    exit 1
  fi
}

# the menu for selecting and copying the decrypted data
copy_key_menu() {
  if [[ "$CHOICE" == "username" ]]; then
    wl-copy "$USERNAME"
    notify-send "username copied, clearing in $CLIP_TIME seconds ..."
    nohup sh -c "sleep $CLIP_TIME; wl-copy --clear" > /dev/null 2>&1 &
    disown
  elif [[ "$CHOICE" == "password" ]]; then
    wl-copy "$PASSWORD"
    notify-send "password copied, clearing in $CLIP_TIME seconds ..."
    nohup sh -c "sleep $CLIP_TIME; wl-copy --clear" > /dev/null 2>&1 &
    disown
  elif [[ -n "${PASSDATA_ARR[$CHOICE]}" ]]; then
    wl-copy "${PASSDATA_ARR[$CHOICE]}"
    notify-send "$CHOICE copied, clearing in $CLIP_TIME seconds ..."
    nohup sh -c "sleep $CLIP_TIME; wl-copy --clear" > /dev/null 2>&1 &
    disown
  else
    exit 1
  fi
}

# get the key that the user chooses to autotype
autotype_choice_data() {
  if [[ "$BACKEND" == "bemenu" ]]; then
    CHOICE="$(printf '%s\n' "autotype" "username" "password" "${!PASSDATA_ARR[@]}" | bemenu)"
  elif [[ "$BACKEND" == "rofi" ]]; then
    CHOICE="$(printf '%s\n' "autotype" "username" "password" "${!PASSDATA_ARR[@]}" | rofi -dmenu)"
  elif [[ "$BACKEND" == "fzf" ]]; then
    CHOICE="$(printf '%s\n' "autotype" "username" "password" "${!PASSDATA_ARR[@]}" | fzf)"
  else
    exit 1
  fi

  if [[ -z "$CHOICE" ]]; then
    exit 1
  fi
}

# the menu for selecting and autotyping the decrypted data
autotype_key_menu() {
  if [[ "$CHOICE" == "autotype" ]]; then
    wtype -s 100 "$USERNAME" && wtype -s 100 -k Tab -- && wtype -s 100 "$PASSWORD"
  elif [[ "$CHOICE" == "username" ]]; then
    wtype "$USERNAME"
  elif [[ "$CHOICE" == "password" ]]; then
    wtype "$PASSWORD"
  elif [[ -n "${PASSDATA_ARR[$CHOICE]}" ]]; then
    wtype "${PASSDATA_ARR[$CHOICE]}"
  else
    exit 1
  fi
}

# cleanup jobs before the script exits
clean() {
  wl-copy --clear
  unset -v PASSFILE
  unset -v USERNAME
  unset -v PASSWORD
  unset -v PASSDATA_ARR
  unset -v CHOICE
}

main() {
  get_pass_file
  get_pass_data

  if [[ "$WTYPE" -eq 1 ]]; then
    autotype_choice_data
    autotype_key_menu
  else
    copy_choice_data
    copy_key_menu
  fi
}

main
